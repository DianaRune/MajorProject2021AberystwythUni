//Include the JavaFX libraries in order to read and generate the Application Scene...

import javafx.animation.KeyFrame;
import javafx.animation.Timeline;
import javafx.application.Application;
import javafx.concurrent.Task;
import javafx.fxml.FXMLLoader;
import javafx.geometry.Point3D;
import javafx.scene.image.Image;
import javafx.scene.Group;
import javafx.scene.Parent;
import javafx.scene.Scene;
import javafx.scene.paint.Color;
import javafx.scene.paint.PhongMaterial;
import javafx.scene.transform.Rotate;
import javafx.scene.transform.Translate;
import javafx.stage.Stage;
import javafx.util.Duration;
//Importing this function allows for the exception to be called in the case the "main.fxml" file is not loaded properly.
import java.io.IOException;

//This class handles all the FXML generated by SceneBuilder and some of it's UI operations. Extending the application...
public class GUI extends Application {

    //The boolean that determines whether the current Colour index should increment/decrement.
    static boolean colourReverse = false;
    //The current index for the 'hexColours' array.
    static int currentColor = 0;
    //The current index for the 'illuminationMaps' array.
    static int currentMap = 0;
    //The angle at which the graphic should rotate on the x-axis for every 0.05 duration thread/Task cycle. (Until the 'totalAngle' boundaries are met and the integer sign is inverted).
    static int angle = 2;
    //The accumulative angle that has been applied to the graphic about the origin point.
    static int totalAngle = 0;
    //The y displacement that will be applied to the graphic's 'face' alone. (Until the 'totalAngle' boundaries are met and the integer sign is inverted).
    //(Makes the graphic appear to nod.)
    static int yTranslateAmount = 5;

    //Upon runtime this method is the first to execute after initialisation. It reads the FXML and creates the application window on the stage, an IOException is thrown in case the FXML document can't be read.
    //(Most of the graphical manipulation is called/handled here.)
    @Override
    public void start(Stage mainStage) throws IOException {

        //The FXML file describing the interface and it's functions is loaded in so its objects may be accessed.
        FXMLLoader loader = new FXMLLoader(getClass().getResource("main.fxml"));
        //The FXML interface is loaded into the Parent 'root' node to be displayed in a scene.
        //(It is important that the FXML is loaded before the controller is assigned.)
        Parent root = loader.load();
        //The controller class is loaded in, this is where the UI functionality will be called from.
        Controller controller = loader.getController();
        //The scene is created and the root is passed.
        Scene scene = new Scene(root);
        //An application window (Stage) can now be made for the scene to be displayed in.
        mainStage.setScene(scene);
        //The application window is given a name.
        mainStage.setTitle("RNG MUSIC GENERATOR");
        //Sets the stage to be displayed on the screen to the user.
        mainStage.show();

        //The graphic objects are grouped in order to manipulate them as one object...
        Group graphicGroup = new Group();
        //The individual objects are added to the 'Group' object.
        graphicGroup.getChildren().add(controller.graphicBody);
        graphicGroup.getChildren().add(controller.graphic1);
        graphicGroup.getChildren().add(controller.graphic2);
        graphicGroup.getChildren().add(controller.graphic3);
        graphicGroup.getChildren().add(controller.graphic4);
        graphicGroup.getChildren().add(controller.graphic5);
        //The group is added to the children of the main controller, to allow display and enable functionality.
        controller.panelRoot.getChildren().add(graphicGroup);

        //The graphic's 'face' objects are grouped too, allowing for separate control over these object's alone.
        Group graphicFace = new Group();
        graphicFace.getChildren().add(controller.graphic1);
        graphicFace.getChildren().add(controller.graphic2);
        graphicFace.getChildren().add(controller.graphic3);
        graphicFace.getChildren().add(controller.graphic4);
        graphicFace.getChildren().add(controller.graphic5);
        //The group is added to the children of the main controller, to allow display and enable functionality.
        controller.panelRoot.getChildren().add(graphicFace);

        //A new material is made to be set to the just the face of the Graphic.
        PhongMaterial faceColour = new PhongMaterial();
        //It makes these objects appear pure black.
        faceColour.setDiffuseColor(Color.web("#000000"));
        controller.graphic1.setMaterial(faceColour);
        controller.graphic2.setMaterial(faceColour);
        controller.graphic3.setMaterial(faceColour);
        controller.graphic4.setMaterial(faceColour);
        controller.graphic5.setMaterial(faceColour);

        //An array of Colours (based on their web values) is made. These will be applied to the body of the graphic, in a back and fore, linear fashion.
        Color[] hexColors = {Color.web("#a1ffd5"), Color.web("#a1ffeb"), Color.valueOf("#a1fffc"), Color.valueOf("#a1ecff"), Color.valueOf("#a1d5ff"), Color.valueOf("#a1c0ff"), Color.valueOf("#a1acff"), Color.valueOf("#b1a1ff"), Color.valueOf("#c3a1ff"), Color.valueOf("#d6a1ff"), Color.valueOf("#f2a1ff"), Color.valueOf("#ffa1f2")};
        //An array of Images is made. These will be applied to the body of the graphic, in a cyclic fashion.
        Image[] illuminationMaps = {new Image(getClass().getResourceAsStream("Graphic_Images/Sparkle1.jpg")), new Image(getClass().getResourceAsStream("Graphic_Images/Sparkle2.jpg")), new Image(getClass().getResourceAsStream("Graphic_Images/Sparkle3.jpg"))};
        //The material that will be applied to the body of the graphic is created.
        PhongMaterial bodyMaterial = new PhongMaterial();

        //This is an infinite thread called a 'Task' to change the graphic 'body's' colour and 'pattern'.
        Task<String> graphicColour = new Task<>() {
            @Override
            protected synchronized String call() {
                //The timeline that controls thread duration for our 'animation'.
                Timeline timeline = new Timeline(
                        //We define the thing that should happen, (the 'event')...
                        new KeyFrame(
                                //...For how long.
                                Duration.seconds(0.3),
                                (event ->
                                {
                                    //The graphic's 'body' is set to.
                                    //The chosen colour from the colour array is being applied to the material.
                                    bodyMaterial.setDiffuseColor(hexColors[currentColor]);
                                    //The chosen 'map' from the illumination-map array is being applied to the material.
                                    //The illumination map is an image indicating which areas of the textures should be bright.
                                    //(The images being applied will have the pattern of white sparkles on the object's surface.)
                                    bodyMaterial.setSelfIlluminationMap(illuminationMaps[currentMap]);
                                    //The material is applied to the object.
                                    controller.graphicBody.setMaterial(bodyMaterial);
                                    //The map array index is incremented so another map is used on the next cycle.
                                    currentMap++;
                                    //If the map index is out of bounds of it's array, and there is no 'next map'...
                                    if (currentMap >= illuminationMaps.length) {
                                        //The index is reset to 0, and the first map will be used again.
                                        currentMap = 0;
                                    }
                                    //If the colour index is out of bounds of it's array...
                                    if (currentColor >= (hexColors.length - 1)) {
                                        //A 'latch' is set for the colours to reverse with a decremental array index...
                                        colourReverse = true;
                                        //Until the index hits zero...
                                    } else if (currentColor == 0) {
                                        //And they are incremental again.
                                        colourReverse = false;
                                    }
                                    //If reversing the colours cycle backwards with a decremental array index.
                                    if (colourReverse) {
                                        currentColor--;
                                        //Otherwise the colours cycle forwards with an incremental array index.
                                    } else {
                                        currentColor++;
                                    }
                                }
                                )
                        )
                );
                //This event will continue forever as desired.
                timeline.setCycleCount(Timeline.INDEFINITE);
                //The timeline of the event within this Task and Thread is told it is to play.
                timeline.play();
                return null;
            }
        };
        //The Thread starts to play forever.
        new Thread(graphicColour).start();

        //The boundaries that the accumulative angle, 'totalAngle', should not exceed.
        //The maximum, the amount the graphic is allowed to look up.
        int MAXIMUMANGLE = 20;
        //The minimum, the amount the graphic is allowed to look down.
        int MINIMUMANGLE = -20;

        //This is an infinite thread called a 'Task' to simulate graphical motion by updating the graphic group's position and rotation.
        Task<String> graphicMotion = new Task<>() {
            @Override
            protected synchronized String call() {
                //The timeline that controls thread duration for our 'animation'.
                Timeline timeline = new Timeline(
                        //We define the thing that should happen, (the 'event')...
                        new KeyFrame(
                                //...For how long.
                                Duration.seconds(0.05),
                                (event ->
                                {
                                    //Create new 'Rotate' object to apply 'angle' to the graphic's x axis.
                                    Rotate rotate = new Rotate(angle, new Point3D(1, 0, 0));
                                    //The pivot that the object will be rotated around is set.
                                    rotate.setPivotX(150);
                                    rotate.setPivotY(225);
                                    //The rotation is applied to the objects.
                                    graphicGroup.getTransforms().add(rotate);
                                    graphicFace.getTransforms().add(rotate);
                                    //The total angle (the total of 'angles' that have been applied in this endless thread already.) determines when the 'animation'/rotation effect should reverse.
                                    totalAngle = totalAngle + angle;

                                    //The translation is applied to the graphic's 'face' alone.
                                    //Create new 'Rotate' object to apply 'angle' to the graphic's face y axis...
                                    //This makes the graphic appear to nod as the face will move up and down where, without, it would appear to do stationary X axis rotation without displacement.
                                    Translate translate = new Translate();
                                    //The y translation is set...
                                    translate.setY(yTranslateAmount);
                                    graphicFace.getTransforms().add(translate);

                                    //If the total angle applied has met or exceeded the desired rotation boundaries, we want the opposite action to occur next, until either condition is met again...
                                    //Therefore, if the graphic is looking up at its maximum...
                                    if (totalAngle >= MAXIMUMANGLE) {
                                        //It set set to look down until the angle reaches the minimum...
                                        //The negative angle amount allows for a negative x axis rotation.
                                        angle = -angle;
                                        //The negative translation amount allows for a negative y axis translation.
                                        yTranslateAmount = -yTranslateAmount;
                                        //Then if the graphic is looking down at its minimum, it is set to look up again.
                                    } else if (totalAngle <= MINIMUMANGLE) {
                                        //The positive angle amount allows for a positive x axis rotation.
                                        angle = -angle;
                                        //The positive translation amount allows for a positive y axis translation.
                                        yTranslateAmount = -yTranslateAmount;
                                    }
                                }
                                )
                        )
                );
                //This event will continue forever as desired.
                timeline.setCycleCount(Timeline.INDEFINITE);
                //The timeline of the event within this Task and Thread is told it is to play.
                timeline.play();
                return null;
            }
        };
        //The Thread starts to play forever.
        new Thread(graphicMotion).start();
    }

    //The main function launches the application.
    public static void main(String[] args) {
        launch(args);
    }
}
